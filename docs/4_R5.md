# About R<sup>5</sup>

Benureau and Rougier in [their work from 2018](https://doi.org/10.3389/fninf.2017.00069) defined five characteristics that a scientific code should possess in order to be regarded as a first-class research output. These five characteristics translate into principles that those who write scientific code should follow. In short, a scientific code should be:
1. Re-runnable  (R<sup>1</sup>)
2. Repeatable   (R<sup>2</sup>)
3. Reproducible (R<sup>3</sup>)
4. Reusable     (R<sup>4</sup>)
5. Replicable   (R<sup>5</sup>)

The above five terms were initially coined by in the presentation *["What is Reproducibility? - The R<sup>*</sup> brouhaha"](http://repscience2016.research-infrastructures.eu/img/CaroleGoble-ReproScience2016v2.pdf)* from 2016.


Although these characteristics are tailored to scientific code development, they can still be very useful applied to other (research) digital objects such as data *per se* and workflows.

Readers will find some level of overlap with Open Science and FAIR data principles but should note that the goal is to provide a different perspective on the same problem - namely, how research outputs can maintain value over the long term.

# R<sup>1</sup>: Re-runnable
> The code should be re-runnable (i.e., executable)

We often face the issue that our code which initially worked perfectly in a year time cannot be executed. Typically, you will end up updating libraries, reintalling operating system, updating compiler, changing computer or some of it components, etc. all of which will results in a failure to execute the code. It pretty impossible to create a future-proof code, however, it is possible to recreate and save the old execution environment and thus assure that the code will be re-runnable. To do this we can create a virtual machine, which replicates the old execution environment, deploy the code inside of it, and then simply share/publish the virtual machine for anyone to use it. [Docker containers](https://www.docker.com/resources/what-container) are popular choice for such a work.

# R<sup>2</sup>: Repeatable
> The code should produce the same results every time it is executed

This principle assures that the code produce the same output over successive runs. One way to achieve this is to establish testing of the code where one defines set of inputs to the code for which the resulting output and simply compare the test results. Repeatability is not always possible or easy. Even if we achieve R<sup>1</sup> running the virtual machine on computer than the original one will probably yield slightly different results due to the hardware settings, so some tolerances should be set on the output results. To fully achieve R<sup>2</sup> one would not only need a copy of the execution environment but also a copy of the old hardware.

# R<sup>3</sup>: Reproducible
> The code should allow those who use it to reobtain the published results


# R<sup>4</sup>: Reusable
> The code  should be easy to use, understand and modify

# R<sup>5</sup>: Replicable
> A clear an unambiguous algorithmic description of the code should available as a reference allowing the code replication in other programming languages than one chosen for an initial algorithm implementation
